function t(t,e,r,n,a,s,i){try{var o=t[s](i),c=o.value}catch(t){return void r(t)}o.done?e(c):Promise.resolve(c).then(n,a)}function e(e){return function(){var r=this,n=arguments;return new Promise((function(a,s){var i=e.apply(r,n);function o(e){t(i,a,s,o,c,"next",e)}function c(e){t(i,a,s,o,c,"throw",e)}o(void 0)}))}}class r{constructor(){this._enc=new TextEncoder,this._encodeMessage=t=>this._enc.encode(t)}_str2ab(t){const e=new ArrayBuffer(t.length),r=new Uint8Array(e);for(let e=0,n=t.length;e<n;e++)r[e]=t.charCodeAt(e);return e}_ab2str(t){return String.fromCharCode.apply(null,Array.from(new Uint8Array(t)))}async generateKeyPair(){return window.crypto.subtle.generateKey({name:"RSA-PSS",modulusLength:4096,publicExponent:new Uint8Array([1,0,1]),hash:"SHA-512"},!0,["sign","verify"])}importCryptoKey(t){const e=t.substring("-----BEGIN PUBLIC KEY-----".length,t.length-"-----END PUBLIC KEY-----".length),r=atob(e),n=this._str2ab(r);return window.crypto.subtle.importKey("spki",n,{name:"RSA-PSS",hash:"SHA-512"},!0,["verify"])}publickeyToArray(t){const e=t.substring("-----BEGIN PRIVATE KEY-----".length,t.length-"-----END PRIVATE KEY-----".length),r=atob(e);return this._str2ab(r)}importCryptoPrivateKey(t){const e=t.substring("-----BEGIN PRIVATE KEY-----".length,t.length-"-----END PRIVATE KEY-----".length),r=atob(e),n=this._str2ab(r);return window.crypto.subtle.importKey("pkcs8",n,{name:"RSA-PSS",hash:"SHA-512"},!0,["sign"])}async exportCryptoKey(t){const e=await window.crypto.subtle.exportKey("spki",t),r=this._ab2str(e);return`-----BEGIN PUBLIC KEY-----\n${btoa(r)}\n-----END PUBLIC KEY-----`}async exportPrivateCryptoKey(t){const e=await window.crypto.subtle.exportKey("pkcs8",t),r=this._ab2str(e);return`-----BEGIN PRIVATE KEY-----\n${window.btoa(r)}\n-----END PRIVATE KEY-----`}async sign(t,e){let r=await window.crypto.subtle.sign({name:"RSA-PSS",saltLength:128},t,this._encodeMessage(e));const n=this._ab2str(r);return window.btoa(n)}async verifySignature(t,e,r){const n=atob(e),a=this._str2ab(n);return await window.crypto.subtle.verify({name:"RSA-PSS",saltLength:128},t,a,this._encodeMessage(r))}async generateFingerprint(t){const e=await crypto.subtle.digest("SHA-256",this._enc.encode(t)),r=Array.from(new Uint8Array(e)).map((t=>t.toString(16).padStart(2,"0"))).join("");return console.log(r),r}}class n{constructor(t){Object.assign(this,t)}}class a{constructor(){this.set=async(t,e)=>{localStorage.setItem("identity_"+btoa(t),JSON.stringify(e))},this.get=async t=>{const e=localStorage.getItem("identity_"+btoa(t));if(e)return new n(JSON.parse(e))},this.remove=async t=>{t.map((t=>"identity_"+btoa(t))).forEach((t=>localStorage.removeItem(t)))},this.getAll=async()=>{const t={};return Object.entries(localStorage).filter((t=>t[0].startsWith("identity_"))).forEach((e=>t[e[0].substr("identity_".length)]=JSON.parse(e[1]))),t}}}class s{constructor(t,e){this.cryptoWrapper=t,this.store=e}static get Instance(){var t;return null!==(t=this._Instance)&&void 0!==t?t:this._Instance=new s(new r,new a)}async generateIndentity(t){const{privateKey:e,publicKey:r}=await this.cryptoWrapper.generateKeyPair(),n=await this.cryptoWrapper.exportCryptoKey(r),a={name:t,publicKey:n,privateKey:await this.cryptoWrapper.exportPrivateCryptoKey(e),fingerprint:await this.cryptoWrapper.generateFingerprint(n)};return await this.store.set(a.name,a),a}async signAndGetpublicKey(t,e){const r=await this.store.get(t);if(!r)return;const n=await this.cryptoWrapper.importCryptoPrivateKey(r.privateKey),a=await this.cryptoWrapper.sign(n,e);return{publicKey:r.publicKey,name:r.name,signed:a,hnsRandom:e}}async fetchAllIdentityName(){const t=await this.store.getAll();return Object.keys(t).map((e=>(console.log({i:t[e]}),{name:atob(e),fingerprint:t[e].fingerprint})))}async GetIdentityByName(t){return{name:t,fingerprint:(await this.store.get(t)).fingerprint}}async deleteIdentity(t){try{return await this.store.remove([t]),!0}catch(t){return console.warn(t),!1}}}s._Instance=null;var i=s.Instance;export{e as _,i};
